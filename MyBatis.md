# MyBatis-Spring执行流程
## 初始化Mapper和解析XML和SQL
1. SqlSessionFactoryBean的初始化方法afterPropertiesSet会构建实际的SqlSessionFactory实例
2. 构建过程中
    1. 使用XMLConfigBuilder解析XML/注解基础配置文件
    2. 对所有mapperLocations中的配置xml文件使用XMLMapperBuilder.parse进行xml解析
        1. 在configurationElement方法中使用XMLStatementBuilder.parseStatementNode中构建SqlSource使用MapperBuilderAssistant.addMappedStatement添加为MappedStatement
        2. 在bindMapperForNamespace方法中使用Configuration.addMapper->MapperRegistry.addMapper进行解析,方法给每个Mapper实例化一个MapperProxyFactory缓存起来,使用MapperAnnotationBuilder.parse->MapperAnnotationBuilder.parseStatement解析Mapper接口类中所有方法构建SqlSource,然后使用MapperBuilderAssistant.addMappedStatement添加为MappedStatement
        3. 另外：在mybatis-plus中自带的getById等方法就是用MybatisConfiguration代替了mybatis的Configuration来调用addMapper方法使用MybatisMapperRegistry的addMapper方法注入自定义SQL方法实现没有XML也有固定的方法可以使用
3. 容器启动时AutoConfiguredMapperScannerRegistrar使用ClassPathMapperScanner扫描所有Mapper注解的类为BeanDefinition并且设置beanClass为MapperFactoryBean.class,设置autowireMode为AUTOWIRE_BY_TYPE(属性上没有注解也能自动注入),这样MapperFactoryBean里面的set方法都会被执行来自动注入值
## 获取Mapper对象
1. MapperFactoryBean的父类中有个属性sqlSession内容为SqlSessionTemplate,这是在创建Mapper的bean时new出来设置的
2. 实际获取Mapper的bean时就通过MapperFactoryBean的getObject方法调用SqlSessionTemplate的getMapper方法最终调用MapperRegistry的getMapper方法
3. 获取到SqlSessionFactory实例化时注册的MapperProxyFactory来newInstance一个JDK动态代理,代理的接口是Mapper,执行InvocationHandler为MapperProxy
4. MapperProxy的invoke方法会调用MapperMethod的execute方法将执行方法统一转换成SqlSession中的方法通过SqlSession实际执行
## 执行方法
1. 执行Mapper方法时通过SqlSessionTemplate中的sqlSessionProxy来进行的
   - sqlSessionProxy是一个在SqlSessionTemplate构造方法中生成的JDK动态代理,接口为SqlSession,InvocationHandler为SqlSessionInterceptor
   - invoke方法中会通过SqlSessionUtils的getSqlSession方法获取DefaultSqlSession来实际执行方法,这样是为了处理事务问题
   - 获取DefaultSqlSession是通过SqlSessionFactory的openSession实现的
   - 获取DefaultSqlSession的过程中会调用Configuration的newExecutor方法根据executorType来创建Executor,创建完的Executor会先放到拦截器链中处理后再进行使用
   - SqlSessionTemplate实际上就是使用了静态代理模式对查询操作进行了增强,实际操作还是DefaultSqlSession在执行
2. 在DefaultSqlSession中的方法执行都是调用的Executor的query/update两个方法,因为Configuration的属性cacheEnabled默认是true,所以默认的Executor就是CachingExecutor
3. 这是通过装饰器模式对BaseExecutor增强的执行器,增强的内容就是二级缓存,但是最终是否走缓存逻辑还是要根据MappedStatement的cache属性来判断,这个属性在构建MappedStatement的时候就已经确定了
   - XML通过XMLMapperBuilder.configurationElement.cacheElement根据cache节点配置
   - 注解通过MapperAnnotationBuilder.parse.parseCache根据CacheNamespace注解配置
4. 所有缓存内容都是先存放事务缓存管理器的临时暂存区,暂存区根据命名空间区分,每个命名空间有自己的暂存区,代码实现就是Map,提交时再刷新到二级缓存
5. 如果未命中二级缓存则调用BaseExecutor的query/update方法来执行,BaseExecutor是一个抽象类,其实现有SimpleExecutor、ReuseExecutor、BatchExecutor,执行query/update时使用模板方法模式调用实现类的doQuery和doUpdate方法,BaseExecutor的主要作用是统一管理一级缓存
6. 在Executor的doQuery和dpUpdate方法中实际使用StatementHandler来最终执行query/update,流程为prepare(创建Statement)、parameterize(设置参数)、query/update(执行)
   - StatementHandler是一个接口,其实现也是通过模板方法模式,BaseStatementHandler是抽象模板,提供统一操作的抽象,最终实现有SimpleStatementHandler、PreparedStatementHandler、CallableStatementHandler
   - Executor执行流程
     1. 通过Configuration的newStatementHandler方法来构建StatementHandler,会先new一个RoutingStatementHandler作为装饰器,构造方法中根据MappedStatement的getStatementType值来判断装饰的实际StatementHandler并且创建出来
     2. 通过BaseExecutor的getConnection方法获取连接,在BaseStatementHandler的prepare方法中调用再调用子类的instantiateStatement方法创建Statement
     3. 调用StatementHandler子类的parameterize方法使用ParameterHandler来设置参数
     4. 调用StatementHandler子类的query/update最终执行Statement的execute方法完成SQL的执行并且调用ResultSetHandler来处理结果结果集返回
## 插件
1. 插件入口:Executor/StatementHandler/ParameterHandler/ResultSetHandler他们在Configuration中进行创建,创建完成后都会调用InterceptorChain.pluginAll来进行插件处理
2. InterceptorChain是在创建SqlSessionFactory的时候初始化的
3. 插件执行逻辑
   1. 在需要拦截的对象创建完成时调用拦截链遍历插件调用插件的plugin方法对对象进行包装,包装使用Plugin.wrap方法
   2. 使用插件签名中定义的接口来创建动态代理,执行InvocationHandler为Plugin,invoke方法会根据插件的签名注解判断是否为要拦截的方法
   3. 如果是则直接通过Plugin中包含的插件对象执行插件的intercept方法,否则执行原方法
